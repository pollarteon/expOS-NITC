alias userSP R0; 
userSP=SP; 
[PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE + 1] * 16) + 13] = SP; 
SP = [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 11] * 512 - 1; 

[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 9] = 9; //Setting mode flag to exec Mode


alias physicalPageNum R1;
alias offset R2;
alias fileNameAddr R3;
physicalPageNum = [PTBR + 2 * ((userSP - 4)/ 512)];
offset = (userSP - 4) % 512;
fileNameAddr = (physicalPageNum * 512) + offset;
alias fileName R4;
fileName=[fileNameAddr];

alias valid R5;
alias i R6;
alias inode_index R7;

//extracting inode table entry number of entered file name
i=0;
valid=0;
while(i<MAX_FILE_NUM) do

	if([INODE_TABLE+ 16*i + 1]==fileName && [INODE_TABLE+16*i]==3) then //file type should be executable
		valid=1;
		inode_index=i;
		break;
	endif;
	i=i+1;
endwhile;

//Failure case(File not found)
if(valid==0) then
	
	//Setting return value as -1 (Failure)
	alias physicalAddrRetVal R8;
	physicalAddrRetVal = ([PTBR + 2 * ((userSP - 1) / 512)] * 512) + ((userSP - 1) % 512);
	[physicalAddrRetVal] = -1;

	//reset mode flag (0 indicates process is in user mode).
	[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 9] = 0;
	
	
	SP = userSP;
	
	ireturn;
endif;


//Calling "Exit Process" function
alias PID_exit R10;
PID_exit=[SYSTEM_STATUS_TABLE + 1];

backup;
R1=3; 
R2=[SYSTEM_STATUS_TABLE + 1];
call MOD_1;

restore;


alias userAreaPageNo R8;

userAreaPageNo=[PROCESS_TABLE+16*[SYSTEM_STATUS_TABLE+1]+11];

//Setting up per-process resource table in last 16 words of user area page
alias ind R13;
ind=496;
while(ind<=511) do
	[userAreaPageNo*512+ind]=-1;
	ind=ind+2;
endwhile;


//Reclaiming the same page by incrementing the memory free list entry of user area page
[MEMORY_FREE_LIST+userAreaPageNo]=[MEMORY_FREE_LIST+userAreaPageNo]+1;

[SYSTEM_STATUS_TABLE+2]=[SYSTEM_STATUS_TABLE+2]-1;

SP = [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 11] * 512 - 1;
[PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 4]=RUNNING;
[PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 7]=inode_index;



//Allocating new pages and setting the page table entries for the new process

PTBR=PAGE_TABLE_BASE+[SYSTEM_STATUS_TABLE+1]*20;

//Library
[PTBR+0]=63;
[PTBR+1]="0100";
[PTBR+2]=64;
[PTBR+3]="0100";


//stage 19 invalidating heap entry


[PTBR+4]=-1;
[PTBR+5]="0000";
[PTBR+6]=-1;
[PTBR+7]="0000";


//Stack
backup;
R1=1;
call MOD_2;
[PTBR+16]=R0;
[PTBR+17]="0110";
restore;

backup;
R1=1;
call MOD_2;
[PTBR+18]=R0;
[PTBR+19]="0110";
restore;

backup;

//allocation only for first code block of the process
backup;
R1 = 5; //get code Page functionNumber;
R2 = [SYSTEM_STATUS_TABLE+1];
R3 = [INODE_TABLE+(16*inode_index)+8];
call MOD_2;
[PTBR+8] = R0;
[PTBR+9] = "0100";
restore;

//invalidating all other code pages
[PTBR+10]=-1;
[PTBR+11]="0000";
[PTBR+12]=-1;
[PTBR+13]="0000";
[PTBR+14]=-1;
[PTBR+15]="0000";

//initialising disk map table or the exec process;
[DISK_MAP_TABLE+[SYSTEM_STATUS_TABLE+1]*10+0]=-1;
[DISK_MAP_TABLE+[SYSTEM_STATUS_TABLE+1]*10+1]=-1;
[DISK_MAP_TABLE+[SYSTEM_STATUS_TABLE+1]*10+2]=-1;
[DISK_MAP_TABLE+[SYSTEM_STATUS_TABLE+1]*10+3]=-1;
[DISK_MAP_TABLE+[SYSTEM_STATUS_TABLE+1]*10+4] = [INODE_TABLE+16*inode_index+8];
[DISK_MAP_TABLE+[SYSTEM_STATUS_TABLE+1]*10+5] = [INODE_TABLE+16*inode_index+9];
[DISK_MAP_TABLE+[SYSTEM_STATUS_TABLE+1]*10+6] = [INODE_TABLE+16*inode_index+10];
[DISK_MAP_TABLE+[SYSTEM_STATUS_TABLE+1]*10+7] = [INODE_TABLE+16*inode_index+11];
[DISK_MAP_TABLE+[SYSTEM_STATUS_TABLE+1]*10+8]=-1;
[DISK_MAP_TABLE+[SYSTEM_STATUS_TABLE+1]*10+9]=-1;

//Setting top of SP to entry point
[[PTBR+16]*512] = [[PTBR+8]*512+1];

//changing back to user stack
SP=8*512;

//reset mode flag (0 indicates process is in user mode).
[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 9] = 0;

ireturn;