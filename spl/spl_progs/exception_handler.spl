breakpoint;

//setting mode flag to -1(Exception handler)
[PROCESS_TABLE +[SYSTEM_STATUS_TABLE+1]*16 + 9]=-1;

//setting Sp to kernel stack

[PROCESS_TABLE +[SYSTEM_STATUS_TABLE+1]*16 +13]=SP;
SP =[PROCESS_TABLE +[SYSTEM_STATUS_TABLE+1]*16 + 11]*512-1;

backup;
multipush(EIP);
if( (EC!=0) || ([PROCESS_TABLE +[SYSTEM_STATUS_TABLE + 1]*16+13] == (PTLR*512-1))) then
	print("!pagefault");
	R1=3;
	R2=[SYSTEM_STATUS_TABLE+1];
	call MOD_1; //exit process function
	call MOD_5;
endif;

alias PID R4;
PID=[SYSTEM_STATUS_TABLE+1];
alias blockNo R2;
blockNo=[DISK_MAP_TABLE+PID*10+EPN];
if((EPN>=4)&&(EPN<=7)) then
	multipush(R2,R4);
	R1=5;
	PID=[SYSTEM_STATUS_TABLE+1];
	blockNo=[DISK_MAP_TABLE+PID*10+EPN];
	
	call MOD_2; //get code page
	multipop(R2,R4);
	[PTBR+EPN*2]=R0;
	[PTBR+2*EPN+1]="1100";

	

endif;
if((EPN>=2)&&(EPN<=3)) then //heap page page fault
        multipush(R2,R4);
        R1=1;
        call MOD_2; //get free page function
        [PTBR+4]=R0;
        [PTBR+5]="1110";
        R1=1;
        call MOD_2;//get free page function
        [PTBR+6]=R0;
        [PTBR+7]="1110";
        multipop(R2,R4);
endif;

[PROCESS_TABLE+[SYSTEM_STATUS_TABLE+1]*16+9]=0;
multipop(EIP);

restore;
SP = [PROCESS_TABLE +([SYSTEM_STATUS_TABLE+1]*16)+13];
SP=SP+1;
[[PTBR + (SP/512)*2]*512+(SP%512)]=EIP;

//assignment breakpoints

//breakpoint;
//	print "diskMapTable";
//	alias j R15;
//	j=0;
//	while(j<=9)do
//		print [DISK_MAP_TABLE+10*[SYSTEM_STATUS_TABLE+1]+j];
//		j = j+1;
//	endwhile;

//breakpoint;
//print "PageTable";
//j = 0;
//while(j<=19)do
//	print [PAGE_TABLE_BASE+20*[SYSTEM_STATUS_TABLE+1]+j];
//	j=j+1;
//endwhile;


ireturn;
 



