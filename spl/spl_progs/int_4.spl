//CREATE AND DELETE SYSTEM CALLS 

alias userSP R0; 
alias Num R1;
alias currPCB R2;
alias inodeEntry R3;
alias syscallNo R4;
alias filename R5;
alias permission R6;
alias i R7;
alias freeInodeIndex R8;
alias physicalAddrRetVal R9;
alias root_file_index R10;
alias inodeIndex R11;
alias j R12;
alias buffer_number R13;

userSP = SP;
[PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE + 1] * 16) + 13] = SP; 
SP = [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 11] * 512 - 1; 


syscallNo=[([PTBR + 2 * ((userSP - 5)/ 512)] * 512) + (userSP - 5) % 512];

//return physical address
physicalAddrRetVal = ([PTBR + 2 * ((userSP - 1) / 512)] * 512) + ((userSP - 1) % 512);

filename = [([PTBR + 2 * ((userSP - 4)/ 512)] * 512) + (userSP - 4) % 512];

if(syscallNo==1) then //CREATE system call

	
	[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 9] = 1;


	permission = [([PTBR + 2 * ((userSP - 3)/ 512)] * 512) + (userSP - 3) % 512];

	//Checking if file is already present 
	
	i=0;
	while(i<MAX_FILE_NUM) do
		if([INODE_TABLE+16*i+1]==filename) then
			[physicalAddrRetVal] = 0;
			[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 9] = 0;
			SP = userSP;
			ireturn;

		endif;
		i=i+1;
	endwhile;

	//Finding free entry in inode table
	freeInodeIndex=-1;
	i=0;
	while(i<60) do
		if([INODE_TABLE+16*i+1]==-1) then
			freeInodeIndex=i;
			break;
		endif;
		i=i+1;
	endwhile;

    //no free inode available
	if(freeInodeIndex==-1) then

		[physicalAddrRetVal] = -1;
		[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 9] = 0;
		SP = userSP;
		ireturn;

	endif;
	inodeEntry = INODE_TABLE+16*freeInodeIndex;
	currPCB = PROCESS_TABLE+16*[SYSTEM_STATUS_TABLE+1];

	//Settig FILE_NAME in inode table
	[inodeEntry+1]=filename;

	//Setting FILE_SIZE in inode table
	[inodeEntry+2]=0;

	//Setting FILE_TYPE to DATA	
	[inodeEntry+0]=DATA;

	//Setting block numbers to -1 (Indicating no disk blocks are allocated for the file)
	
	[INODE_TABLE+16*freeInodeIndex+8]=-1;
	[INODE_TABLE+16*freeInodeIndex+9]=-1;
	[INODE_TABLE+16*freeInodeIndex+10]=-1;
	[INODE_TABLE+16*freeInodeIndex+11]=-1;

	//Setting userID field
	[inodeEntry+3]=[currPCB+3];

	//Setting permission bit
	[inodeEntry+4]=permission;		

	root_file_index = freeInodeIndex;

	[ROOT_FILE+8*root_file_index+0] = filename;
	[ROOT_FILE+8*root_file_index+1] = 0; //File Size
	[ROOT_FILE+8*root_file_index+2] = DATA;//File type

	//Setting username using USER-ID and user table 
	Num = [currPCB+3];
	[ROOT_FILE+8*root_file_index+3]=[USER_TABLE + 2*Num+3];

	[ROOT_FILE+8*root_file_index+4] = permission; //Permission

	
	SP = [currPCB + 13];
	[currPCB + 9] = 0;
	[physicalAddrRetVal] = 0;

	ireturn;

endif;

if(syscallNo==4) then //DELETE system call
	
	
	[currPCB + 9] = 4;

	i=0;
	inodeIndex=-1;
	while(i<MAX_FILE_NUM) do
		if([INODE_TABLE+16*i+1]==filename) then
			inodeIndex=i;
			break;
		endif;
		i=i+1;
	endwhile;

    //if file not present in inode Table
	if(inodeIndex==-1) then
		print "NotPresent";
		[physicalAddrRetVal] = 0;
		[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 9] = 0;
		SP = userSP;
		ireturn;
	endif;

	inodeEntry = INODE_TABLE+16*inodeIndex;
	currPCB = PROCESS_TABLE+16*[SYSTEM_STATUS_TABLE+1];
	
	if([inodeEntry+0]!=DATA) then
		print "NotDataFile";
		
		[physicalAddrRetVal] = -1;
		[currPCB + 9] = 0;
		SP = userSP;
		ireturn;
	endif;
	

    if(([inodeEntry+4]==EXCLUSIVE) && ([currPCB+3]!=1 &&
        [currPCB+3]!=[inodeEntry+3]) ) then
        print "NoPermission";
        [physicalAddrRetVal] = -1;
        [currPCB + 9] = 0;
        SP = userSP;
        ireturn;
    endif;
	

	//ACQUIRING INODE
	backup;
		R1=4; //acquire Inode function
		R3=inodeIndex;
		R2=[SYSTEM_STATUS_TABLE+1]; //PID of current process
		call MOD_0;	
	restore;

	if([FILE_STATUS_TABLE + inodeIndex*4 +1]!=-1) then
		//RELEASING INODE
	print "AlrdyDeltd";
		backup;
			R1=5; // Release inode function
			R3=inodeIndex;
			R2=[SYSTEM_STATUS_TABLE+1]; //PID of current process
			call MOD_0;	
		restore;
		
		[physicalAddrRetVal] = -2;
		[currPCB + 9] = 0;
		SP = userSP;
		ireturn;
	endif;

	//Checking if disk blocks allocated to process are present in buffer
	i=8;
	while(i<=11) do
	//If the block in in buffer
	buffer_number = [inodeEntry+i]%MAX_BUFFER;
	if([BUFFER_TABLE + 4*buffer_number + 0]== [inodeEntry+i]&& 
		[BUFFER_TABLE + 4*buffer_number + 1]==1) then
		[BUFFER_TABLE + 4*buffer_number + 1]=0;
	endif;

	//RELEASE BLOCK
	backup;
		R1=4; //release block function
		R2=[inodeEntry+i];
		R3=[SYSTEM_STATUS_TABLE+1]; //PID of current process
		call MOD_2;	
	restore;
	i=i+1;
	endwhile;

	//Invalidating Inode entry
	[inodeEntry+1]=-1;

	//Invalidating root file entry
	root_file_index=inodeIndex;
	[ROOT_FILE + 8*root_file_index+1]=-1;

	//RELEASING INODE
	backup;
		R1=5; //release Inode function
		R3=inodeIndex;
		R2=[SYSTEM_STATUS_TABLE+1]; //PID of current process
		call MOD_0;	
	restore;


	[physicalAddrRetVal] = 0;
	[currPCB + 9] = 0;
	SP = userSP;
	ireturn;

endif;