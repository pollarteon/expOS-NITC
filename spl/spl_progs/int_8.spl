//FORK

//set mode flag of cureent process to 8(read system call)
[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 9] = 8;

//save user stack pointer
alias userSP R13;
userSP=SP;

alias newPTBR R15;

//switch to kernel stack
[PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE + 1] * 16) + 13] = SP;
SP = [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 11] * 512 - 1;

//Invoking get pcb function to get a new pid for child process
alias newPid_child R14;

R1=1;
R2=[SYSTEM_STATUS_TABLE+1];
call MOD_1;
newPid_child=R0;



if(newPid_child==-1) then
	alias physicalAddrRetVal R12;
	physicalAddrRetVal = ([PTBR + 2 * ((userSP - 1) / 512)] * 512) + ((userSP - 1) % 512);
	[physicalAddrRetVal] = -1;

	//changing back to user stack
	SP = userSP;
	[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 9] = 0;
	ireturn;
endif;

newPTBR=PAGE_TABLE_BASE+newPid_child*20;

//Stack allocating

backup;
R1=1;
call MOD_2;//get free page function
[newPTBR+16]=R0;
[newPTBR+17]=[PTBR+17];
restore;

backup;
R1=1;
call MOD_2;
[newPTBR+18]=R0;
[newPTBR+19]=[PTBR+19];
restore;

//Allocating user area page

backup;
R1=1;
call MOD_2;
[PROCESS_TABLE+16*newPid_child+11]=R0;
restore;

//setting process Table

//copying "user id" from parent to child
[PROCESS_TABLE + 16*newPid_child + 3]=[PROCESS_TABLE + 16*[SYSTEM_STATUS_TABLE + 1] + 3];

//copying "swap flag" from parent to child
[PROCESS_TABLE + 16*newPid_child + 6]=[PROCESS_TABLE + 16*[SYSTEM_STATUS_TABLE + 1] + 6];

//copying "user area swap status" from parent to child
[PROCESS_TABLE + 16*newPid_child + 10]=[PROCESS_TABLE + 16*[SYSTEM_STATUS_TABLE + 1] + 10];

//copying "inode index" from parent to child
[PROCESS_TABLE + 16*newPid_child + 7]=[PROCESS_TABLE + 16*[SYSTEM_STATUS_TABLE + 1] + 7];

//copying "UPTR" from parent to child
[PROCESS_TABLE + 16*newPid_child + 13]=[PROCESS_TABLE + 16*[SYSTEM_STATUS_TABLE + 1] + 13];

//Setting "mode flag" 
[PROCESS_TABLE + 16*newPid_child + 9]=0;

//Setting "KPTR" 
[PROCESS_TABLE + 16*newPid_child + 12]=0;

//Setting "TICK field" 
[PROCESS_TABLE + 16*newPid_child + 0]=0;

//PPID of child == PID of parent
[PROCESS_TABLE + 16*newPid_child + 2]=[PROCESS_TABLE + 16*[SYSTEM_STATUS_TABLE + 1] + 1];

//State of child process is set to created
[PROCESS_TABLE + 16*newPid_child + 4]=CREATED;

//copying pre process resource table from parent to child
alias ind R9;
ind=496;
while(ind<=511) do
	[ [PROCESS_TABLE+16*newPid_child+11]*512 + ind]=[[PROCESS_TABLE+16*[SYSTEM_STATUS_TABLE+1]+11]*512 + ind];
	ind=ind+1;
endwhile;

//copying pre process disk map table from parent to child
alias olddiskMap R11;
olddiskMap= DISK_MAP_TABLE + 10*[SYSTEM_STATUS_TABLE + 1];
alias disk_map R12;
disk_map= DISK_MAP_TABLE + 10*newPid_child;
alias i R10;
i=0;
while(i<=9) do
	[disk_map+i]=[olddiskMap+i];
	i=i+1;
endwhile;

//Setting up page table entries of child process(Sharing pages)
//copying library code and heap

i=0;
while(i<=14) do
	[newPTBR+i]=[PTBR+i];
	[MEMORY_FREE_LIST+[newPTBR+i]]=[MEMORY_FREE_LIST+[newPTBR+i]]+1;
	[newPTBR+i+1]=[PTBR+i+1];
	i=i+2;
endwhile;


//copying user stack contents of parent to child
alias parent_stack R8;
alias child_stack R7;

parent_stack =  [PAGE_TABLE_BASE+[SYSTEM_STATUS_TABLE+1]*20+16];
child_stack = [PAGE_TABLE_BASE+newPid_child*20+16];
i=0;
while(i<=511) do
	[child_stack*512+i] = [parent_stack*512+i];
	i=i+1;
endwhile;

parent_stack =  [PAGE_TABLE_BASE+[SYSTEM_STATUS_TABLE+1]*20+18];
child_stack = [PAGE_TABLE_BASE+newPid_child*20+18];
i=0;
while(i<=511) do
	[child_stack*512+i] = [parent_stack*512+i];
	i=i+1;
endwhile;


//Storing BP on top of kernel stack of newly created process
[[PROCESS_TABLE+16*newPid_child+11]*512] = BP;

//Setting up return values in user stacks of parent and child

//parent and child return values
[( [PTBR+ 2 * ((userSP - 1) / 512)] * 512) + ((userSP - 1) % 512)]= newPid_child;
[([newPTBR + 2 * ((userSP - 1) / 512)] * 512) + ((userSP - 1) % 512)]=0;

//reset the mode flag of parent process to 0
[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 9] = 0;


SP = userSP;
breakpoint;
ireturn;